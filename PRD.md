# Product Requirements Document: FastTrack Dashboard (V1)

**Status:** Draft | **Version:** 1.12 | **Date:** February 6, 2026  
**Author:** Gemini AI | **Persona:** Bespoke Single-User Utility (Headless API & Renderer)

## 1. Executive Summary

### 1.1. Overview
V1 of the FastTrack Dashboard is a headless API and high-fidelity graph generator. It allows a "User of One" (and their AI Agent) to manage metabolic data through a "Fetch-Analyze-Commit" workflow, using GET requests to trigger high-resolution visualizations.

### 1.2. V1 Goals: "Holistic Data Reconciliation"
- **Batch Operations:** Supports "one-shot" multi-point edits and deletions after a full data read.
- **UUID-Based Addressing:** Precise identification for individual metrics within a temporal block.
- **Semantic Data Schema:** All fields are fully spelled out (e.g., `glucose`, `ketones`, `is_weight_measurement`) to ensure AI agents can interpret and manipulate data with zero ambiguity.
- **Static High-Res Output:** Every change (individual or batch) triggers a server-side render of the "Master-View" (PNG format).

## 2. Functional Requirements (FR)

### 2.1. API Layer (FastAPI)
- **FR-101 (Read):** `GET /api/telemetry`. Returns the full nested JSON event stream including UUIDs.
- **FR-102 (Write/Add):** `GET /api/telemetry?action=add&sillykey={SECRET}&key={KEY}&...`.
- **FR-103 (Batch Sync):** `GET /api/telemetry?action=batch&sillykey={SECRET}&payload={URL_ENCODED_JSON}`. Allows the AI agent to reconcile the entire dataset in one transaction.
- **FR-107 (Authentication):** Any data modification request (`add`, `batch`) MUST include the `sillykey` parameter. The value is a dynamic "open secret" computed as: the last 4 digits of the MD5 hash of (Today's Date `YYYY-MM-DD` + `"SALT"`).
    - **Note:** "Today" is defined by the server's system time.
    - **Reference Implementation (Python):**
      ```python
      import hashlib
      from datetime import datetime
      date_str = datetime.now().strftime("%Y-%m-%d") # e.g. "2026-02-06"
      raw = f"{date_str}SALT"
      sillykey = hashlib.md5(raw.encode()).hexdigest()[-4:]
      ```
    - Requests without a valid `sillykey` must be rejected immediately.
- **FR-104 (Image):** `GET /api/chart` serves the latest generated `.png`.
- **FR-105 (Persistence):** Every data change (Add or Batch Sync) MUST trigger an automated Git commit and **push** of the underlying JSON data file to the GitHub repository. This serves as the primary data persistence and disaster recovery mechanism, even in production.
- **FR-106 (Throttling):** The API must implement a "Burst Session" throttle. It should allow up to 20 operations within a 5-minute window, followed by a mandatory quiet period to prevent automated spamming. Daily activity is expected to be ~3-5 sessions.

### 2.2. Rendering Engine (Matplotlib/PCHIP)
- **FR-201:** Replicate the "Master-View v28" logic using flattened versions of the nested JSON.

## 3. The "Refeed & Discomfort" Master Log
This table represents the qualitative ground truth that the AI agent must preserve when reconciling data.

| Timestamp | Event Type | Description | Discomfort / Notes |
| :--- | :--- | :--- | :--- |
| Jan 31, 7:00 PM | Heavy Refeed | Post-skiing Cheat Meal | Stress 8/10: High hunger, followed by a large glucose spike. |
| Feb 1, 1:03 PM | Metric Anchor | Glucose: 116 mg/dL | Stress 2/10: First "dawn surge" after refeed. |
| Feb 2, 10:42 AM | Fat/Fiber Bridge | Walnuts / Keto Snack | Stress 4/10: Managing mid-fast hunger without breaking GKI. |
| Feb 3, 1:30 PM | Fat/Fiber Bridge | Walnuts / Keto Snack | Stress 2/10: Stable; ketones begin climbing again. |
| Feb 5, 7:45 PM | Fat/Fiber Bridge | Jumbo Avocado + Broccoli | Reflux 6/10: Acidic feeling in throat around 1 AM Friday. |
| Feb 6, 6:45 AM | Metric Anchor | Ketones: 6.3 mmol/L | Relief: Acid settled; highest recorded ketosis of the journey. |

## 4. Technical Specifications

### 4.1. Data Model (MetabolicBlock)
```typescript
interface MetabolicBlock {
  timestamp: string; // ISO 8601
  entries: Array<{
    id: string; // UUID v4 generated by server
    key: 'glucose' | 'ketones' | 'body_weight' | 'visceral_fat' | 'total_fat' | 'discomfort' | 'keto_snack' | 'cheat_snack' | 'notes';
    value: number | string;
    simulated: boolean;
  }>;
}
```

### 4.2. State Management (GitOps Model)
- **Primary Store:** A single `telemetry.json` file.
- **Auto-Commit & Sync Utility:** A background process or post-request hook that executes `git add telemetry.json && git commit -m "telemetry: update [source]" && git push origin main` upon every successful write.
- **Production Persistence:** GitHub is the authoritative remote store. Pushing on every change ensures data durability and provides a simple restore path via `git clone` or `git pull`, even in production environments.
- **Concurrency:** Basic file locking to prevent race conditions during the "Fetch-Analyze-Commit" loop.

## 5. Implementation Scratchpad & Ground Truth

### Master-View v28 Prototype (Full Dataset & Batch Logic)
```python
import matplotlib.pyplot as plt
import pandas as pd
import numpy as np
import uuid
import json
from datetime import datetime, timedelta
from scipy.interpolate import PchipInterpolator

# 1. TEMPORAL ANCHOR
# Using UTC for consistency with ISO strings
start_time = datetime(2026, 1, 28, 18, 0)

# 2. FULL NESTED DATASET (Restored & Semantic)
nested_data = [
    {"timestamp": "2026-01-29T18:00:00Z", "entries": [{"id": str(uuid.uuid4()), "key": "body_weight", "value": 230.0, "simulated": False}, {"id": str(uuid.uuid4()), "key": "notes", "value": "Start Anchor", "simulated": False}]},
    {"timestamp": "2026-01-30T16:55:00Z", "entries": [{"id": str(uuid.uuid4()), "key": "glucose", "value": 93.0, "simulated": False}]},
    {"timestamp": "2026-01-31T17:58:00Z", "entries": [{"id": str(uuid.uuid4()), "key": "glucose", "value": 67.0, "simulated": False}, {"id": str(uuid.uuid4()), "key": "ketones", "value": 3.8, "simulated": False}]},
    {"timestamp": "2026-01-31T19:00:00Z", "entries": [{"id": str(uuid.uuid4()), "key": "cheat_snack", "value": "Cheat 1 (Refeed: Heavy)", "simulated": False}, {"id": str(uuid.uuid4()), "key": "discomfort", "value": 8, "simulated": False}]},
    {"timestamp": "2026-01-31T21:48:00Z", "entries": [{"id": str(uuid.uuid4()), "key": "cheat_snack", "value": "Cheat 2 (Refeed: Heavy)", "simulated": False}]},
    {"timestamp": "2026-02-01T13:01:48Z", "entries": [{"id": str(uuid.uuid4()), "key": "glucose", "value": 116.0, "simulated": False}, {"id": str(uuid.uuid4()), "key": "ketones", "value": 2.6, "simulated": False}]},
    {"timestamp": "2026-02-02T10:25:12Z", "entries": [{"id": str(uuid.uuid4()), "key": "glucose", "value": 73.0, "simulated": False}, {"id": str(uuid.uuid4()), "key": "ketones", "value": 2.2, "simulated": False}, {"id": str(uuid.uuid4()), "key": "keto_snack", "value": "Walnuts", "simulated": False}]},
    {"timestamp": "2026-02-03T10:42:00Z", "entries": [{"id": str(uuid.uuid4()), "key": "keto_snack", "value": "Walnuts", "simulated": False}]},
    {"timestamp": "2026-02-03T13:42:00Z", "entries": [{"id": str(uuid.uuid4()), "key": "glucose", "value": 68.0, "simulated": False}, {"id": str(uuid.uuid4()), "key": "ketones", "value": 3.2, "simulated": False}]},
    {"timestamp": "2026-02-04T05:51:00Z", "entries": [{"id": str(uuid.uuid4()), "key": "glucose", "value": 106.0, "simulated": False}, {"id": str(uuid.uuid4()), "key": "ketones", "value": 5.1, "simulated": False}]},
    {"timestamp": "2026-02-04T14:05:00Z", "entries": [{"id": str(uuid.uuid4()), "key": "glucose", "value": 106.0, "simulated": False}, {"id": str(uuid.uuid4()), "key": "ketones", "value": 5.7, "simulated": False}]},
    {"timestamp": "2026-02-05T07:50:00Z", "entries": [{"id": str(uuid.uuid4()), "key": "glucose", "value": 89.0, "simulated": False}, {"id": str(uuid.uuid4()), "key": "ketones", "value": 5.5, "simulated": False}]},
    {"timestamp": "2026-02-05T14:43:00Z", "entries": [{"id": str(uuid.uuid4()), "key": "glucose", "value": 98.0, "simulated": False}, {"id": str(uuid.uuid4()), "key": "ketones", "value": 8.0, "simulated": False}]},
    {"timestamp": "2026-02-05T19:22:00Z", "entries": [{"id": str(uuid.uuid4()), "key": "glucose", "value": 95.0, "simulated": False}, {"id": str(uuid.uuid4()), "key": "ketones", "value": 6.1, "simulated": False}]},
    {"timestamp": "2026-02-05T19:45:00Z", "entries": [{"id": str(uuid.uuid4()), "key": "keto_snack", "value": "Avocado & Broccoli", "simulated": False}, {"id": str(uuid.uuid4()), "key": "discomfort", "value": 6, "simulated": False}]},
    {"timestamp": "2026-02-06T01:00:00Z", "entries": [{"id": str(uuid.uuid4()), "key": "glucose", "value": 84.0, "simulated": False}, {"id": str(uuid.uuid4()), "key": "ketones", "value": 4.8, "simulated": False}]},
    {"timestamp": "2026-02-06T06:45:00Z", "entries": [{"id": str(uuid.uuid4()), "key": "glucose", "value": 99.0, "simulated": False}, {"id": str(uuid.uuid4()), "key": "ketones", "value": 6.3, "simulated": False}]},
    {"timestamp": "2026-02-06T16:33:00Z", "entries": [{"id": str(uuid.uuid4()), "key": "body_weight", "value": 221.6, "simulated": False}, {"id": str(uuid.uuid4()), "key": "notes", "value": "Smart Scale", "simulated": False}]}
]

# --- REFRESHED ENGINE LOGIC ---
def flatten_data(nested):
    rows = []
    for block in nested:
        ts = pd.to_datetime(block["timestamp"])
        row = {"timestamp": ts}
        for entry in block["entries"]:
            row[entry["key"]] = entry["value"]
            if entry["key"] in ["glucose", "ketones", "body_weight"]:
                row[f"is_{entry['key']}_simulated"] = entry["simulated"]
        rows.append(row)
    return pd.DataFrame(rows).sort_values('timestamp')

df = flatten_data(nested_data)
# Handle timezone awareness for hours calculation
df['hours_elapsed'] = df['timestamp'].apply(lambda x: (x.replace(tzinfo=None) - start_time).total_seconds() / 3600)

# Calculate GKI safely (where both exist)
df['gki'] = df.apply(lambda r: (r['glucose'] / 18.016) / r['ketones'] if pd.notnull(r['glucose']) and pd.notnull(r['ketones']) else np.nan, axis=1)

# 3. INTERPOLATION ENGINE (PCHIP for chemistry)
sim_hours = np.linspace(df['hours_elapsed'].min(), df['hours_elapsed'].max(), 1000)
sim_dates = [start_time + timedelta(hours=h) for h in sim_hours]

def get_pchip(sub_df, y_column, target_x):
    sub = sub_df.dropna(subset=[y_column])
    if len(sub) < 2: return np.zeros_like(target_x)
    return PchipInterpolator(sub['hours_elapsed'], sub[y_column])(target_x)

smooth_glucose = get_pchip(df, 'glucose', sim_hours)
smooth_ketones = get_pchip(df, 'ketones', sim_hours)
smooth_gki = get_pchip(df, 'gki', sim_hours)

# WEIGHT SIMULATION (Physiological Decay Model)
# Connecting the only 2 measured points: 230 -> 221.6
weight_start, weight_final = 230.0, 221.6
k_decay = 0.008 
smooth_weight = weight_final + (weight_start - weight_final) * np.exp(-k_decay * (sim_hours - 24))

# 4. CIRCADIAN GLUCOSE BANDING
def get_circadian_band(dates):
    lows, highs = [], []
    for d in dates:
        hour = d.hour + d.minute/60.0
        # Model the Dawn Phenomenon (Peak at 7:00 AM)
        surge = 15 * np.exp(-((hour - 7)**2) / (2 * 1.5**2))
        lows.append(70 + surge * 0.5)
        highs.append(100 + surge)
    return np.array(lows), np.array(highs)

band_low, band_high = get_circadian_band(sim_dates)

# 5. REFEED & BRIDGE ANNOTATIONS
# Extracted from the semantic keys
refeed_events = df[df['cheat_snack'].notnull()]
bridge_events = df[df['keto_snack'].notnull()]

# 6. PLOT GENERATION
plt.rcParams.update({'font.size': 14, 'font.family': 'sans-serif'})
fig, ax1 = plt.subplots(figsize=(20, 14))
plt.subplots_adjust(right=0.5)

# Primary Axis: Glucose
ax1.set_ylabel('Glucose (mg/dL) [Measured]', color='#d62728', fontweight='bold')
ax1.fill_between(sim_dates, band_low, band_high, color='red', alpha=0.08, label='Circadian Healthy Band')
ax1.plot(sim_dates, smooth_glucose, color='#d62728', lw=10, alpha=0.2)
ax1.scatter(df.dropna(subset=['glucose'])['timestamp'], df.dropna(subset=['glucose'])['glucose'], color='#d62728', s=400, edgecolors='black', label='Measured Glucose', zorder=5)
ax1.set_ylim(40, 160)

# Secondary Axis: Ketones
ax2 = ax1.twinx()
ax2.set_ylabel('Ketones (mmol/L) [Measured]', color='#1f77b4', fontweight='bold')
ax2.plot(sim_dates, smooth_ketones, color='#1f77b4', lw=10, alpha=0.2)
ax2.scatter(df.dropna(subset=['ketones'])['timestamp'], df.dropna(subset=['ketones'])['ketones'], marker='s', color='#1f77b4', s=400, edgecolors='black', label='Measured Ketones', zorder=5)
ax2.set_ylim(0, 10)

# Tertiary Axis: GKI
ax_gki = ax1.twinx()
ax_gki.spines['right'].set_position(('outward', 60))
ax_gki.set_ylabel('GKI (Repair Index) [Computed]', color='#9467bd', fontweight='bold')
ax_gki.plot(sim_dates, smooth_gki, color='#9467bd', lw=10, alpha=0.2, ls='--')
ax_gki.scatter(df.dropna(subset=['gki'])['timestamp'], df.dropna(subset=['gki'])['gki'], marker='D', color='#9467bd', s=300, edgecolors='black', label='Computed GKI', zorder=5)
ax_gki.axhline(y=1.0, color='purple', ls='-', lw=5, alpha=0.7, label='Mitophagy Goal (1.0)')
ax_gki.fill_between(sim_dates, 0, 1.0, color='purple', alpha=0.1)
ax_gki.set_ylim(0, 10)

# Quaternary Axis: Weight
ax3 = ax1.twinx()
ax3.spines['right'].set_position(('outward', 120))
ax3.set_ylabel('Body Weight (lbs) [Simulated Path]', color='#2ca02c', fontweight='bold')
ax3.plot(sim_dates, smooth_weight, color='#2ca02c', lw=12, alpha=0.5, label='Simulation Path')

# Markers for ground truth weight
weight_meas = df[(df['body_weight'].notnull()) & (df['is_body_weight_simulated'] == False)]
ax3.scatter(weight_meas['timestamp'], weight_meas['body_weight'], marker='^', color='#2ca02c', s=600, edgecolors='black', label='Measured Anchor', zorder=6)
ax3.axhline(y=220, color='blue', ls='-.', lw=4, alpha=0.5, label='Obesity Exit: 220')
ax3.set_ylim(170, 240)

# Annotate Refeeds and Bridges
for idx, row in refeed_events.iterrows():
    ax1.axvline(x=row['timestamp'], color='salmon', lw=4, alpha=0.6, ls=':')
    ax1.text(row['timestamp'], 158, row['cheat_snack'], rotation=90, verticalalignment='top', fontsize=10, fontweight='bold')

for idx, row in bridge_events.iterrows():
    ax1.axvline(x=row['timestamp'], color='lightgreen', lw=4, alpha=0.6, ls=':')
    ax1.text(row['timestamp'], 158, row['keto_snack'], rotation=90, verticalalignment='top', fontsize=10, fontweight='bold')

plt.title("Master-View v28: Source Code Ground Truth (Restored Engine)", fontsize=24, fontweight='bold', pad=40)
plt.show()
```
